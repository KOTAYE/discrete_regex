# discrete_regex

У цій лабораторній роботі я розробив і реалізував скінченний автомат (Finite State Machine, FSM) для обробки регулярних виразів. Моя реалізація дозволяє аналізувати та оцінювати прості регулярні вирази для визначення, чи відповідає заданий вхідний рядок вказаному шаблону.


Скінченний автомат - це обчислювальна модель, яка складається з:
- Набору станів
- Переходів між станами, які відбуваються у відповідь на вхідні дані
- Початкового стану
- Одного чи кількох термінальних станів

### Регулярні вирази

Регулярні вирази (regex) - це послідовності символів, які визначають шаблон пошуку. Вони часто використовуються для перевірки форматів тексту, пошуку та маніпуляцій з рядками.

У моїй реалізації я підтримую наступні елементи регулярних виразів:
- Точка (`.`) - відповідає будь-якому одиничному символу
- Зірочка (`*`) - повторення попереднього символу нуль або більше разів
- Плюс (`+`) - повторення попереднього символу один або більше разів
- Літеральні символи - відповідають самим собі

## Архітектура програми

Я організував програму за допомогою об'єктно-орієнтованого підходу з використанням класів для представлення різних компонентів скінченного автомата. Основна архітектура включає:

### Базовий абстрактний клас State

```python
class State(ABC):
```

Цей клас визначає інтерфейс для всіх станів у FSM, вимагаючи:
- Метод `check_self(char)` - перевіряє, чи поточний символ обробляється поточним станом
- Метод `check_next(next_char)` - перевіряє наступний стан на основі поточного символу

### Різновиди станів

Я розробив кілька спеціалізованих класів станів для обробки різних аспектів регулярних виразів:

1. **StartState** - початковий стан FSM
2. **TerminationState** - кінцевий стан, який позначає успішне співпадіння
3. **DotState** - обробляє символ `.`, який відповідає будь-якому символу
4. **AsciiState** - обробляє конкретний символ ASCII
5. **StarState** - обробляє оператор `*` (нуль або більше повторень)
6. **PlusState** - обробляє оператор `+` (один або більше повторень)

### Головний клас RegexFSM

```python
class RegexFSM:
```

Цей клас відповідає за перетворення регулярного виразу в мережу взаємопов'язаних станів, які утворюють FSM. Під час ініціалізації я аналізую рядок регулярного виразу символ за символом і створюю відповідні стани та переходи.

## Алгоритм роботи

Моя реалізація складається з двох основних етапів:

### 1. Компіляція регулярного виразу

У конструкторі класу `RegexFSM` я розбираю регулярний вираз і будую відповідний FSM:

1. Створюю початковий та кінцевий стани
2. Послідовно аналізую кожен символ регулярного виразу
3. Для кожного символу створюю відповідний стан:
   - Для літерального символу - `AsciiState`
   - Для `.` - `DotState`
   - Для `*` - `StarState`, пов'язаний з попереднім станом
   - Для `+` - `PlusState`, пов'язаний з попереднім станом
4. Налаштовую переходи між станами
5. З'єдную останній стан з термінальним станом

### 2. Перевірка вхідного рядка

Метод `check_string()` перевіряє, чи відповідає вхідний рядок скомпільованому регулярному виразу:

1. Починаю з початкового стану FSM та першого символу вхідного рядка
2. Підтримую список поточних позицій (стан, позиція у вхідному рядку)
3. Поки є поточні позиції:
   - Вибираю позицію зі списку
   - Якщо досягнуто кінця рядка, перевіряю чи можна перейти до термінального стану
   - Інакше отримую поточний символ та перевіряю переходи до наступних станів
   - Додаю нові позиції до списку
4. Повертаю `True`, якщо знайдено шлях до термінального стану, інакше `False`

## Особливості реалізації

### Обробка специфічних операторів

#### Оператор `*` (нуль або більше повторень)

Я реалізував обробку оператора `*` за допомогою класу `StarState`, який:
1. Перевіряє, чи символ відповідає стану, який повторюється
2. Дозволяє переходи як до самого себе (продовжити повторення), так і до наступного стану (закінчити повторення)

#### Оператор `+` (один або більше повторень)

Аналогічно, клас `PlusState` обробляє оператор `+`, але вимагає принаймні одного повторення.

### Пошук із поверненням (backtracking)

Моя реалізація використовує алгоритм пошуку із поверненням (backtracking), щоб спробувати всі можливі шляхи через FSM. Це особливо важливо для обробки операторів `*` і `+`, де може бути кілька способів співставлення.

## Тестування

Для перевірки коректності моєї реалізації я провів ряд тестів з різними регулярними виразами та вхідними рядками. Ось приклад:

```python
regex_pattern = "a*4.+hi"

regex_compiled = RegexFSM(regex_pattern)

print(regex_compiled.check_string("aaaaaa4uhi"))  # True
print(regex_compiled.check_string("4uhi"))  # True
print(regex_compiled.check_string("meow"))  # False
```

У цьому тесті:
- Регулярний вираз `a*4.+hi` означає: нуль або більше символів 'a', за якими йде '4', будь-який символ, один або більше будь-яких символів, і потім 'hi'
- Рядок "aaaaaa4uhi" відповідає виразу (кілька 'a', потім '4', потім 'u', потім 'hi')
- Рядок "4uhi" також відповідає (нуль 'a', потім '4', потім 'u', потім 'hi')
- Рядок "meow" не відповідає (не починається з 'a*4')

## Обмеження

Моя поточна реалізація має кілька обмежень:
1. Підтримуються лише базові оператори (`.`, `*`, `+`)
2. Не підтримуються групи, символьні класи та альтернативи
3. Немає екранування спеціальних символів
4. Алгоритм пошуку може бути не оптимальним для складних виразів

## Висновки

У цій лабораторній роботі я успішно реалізував скінченний автомат для обробки простих регулярних виразів. Моя реалізація демонструє, як можна використовувати об'єктно-орієнтований підхід для моделювання абстрактних понять, таких як стани та переходи FSM.

Основні здобутки:
1. Розробка модульної та розширюваної архітектури для FSM
2. Реалізація основних елементів регулярних виразів
3. Використання алгоритму пошуку із поверненням для перевірки відповідності
